<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qparser module &mdash; Whoosh 2.5.7 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.5.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Whoosh 2.5.7 documentation" href="../index.html" />
    <link rel="up" title="Whoosh API" href="api.html" />
    <link rel="next" title="query module" href="query.html" />
    <link rel="prev" title="matching module" href="matching.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="query.html" title="query module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="matching.html" title="matching module"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Whoosh 2.5.7 documentation</a> &raquo;</li>
          <li><a href="api.html" accesskey="U">Whoosh API</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-whoosh.qparser">
<span id="qparser-module"></span><h1><tt class="docutils literal"><span class="pre">qparser</span></tt> module<a class="headerlink" href="#module-whoosh.qparser" title="Permalink to this headline">¶</a></h1>
<div class="section" id="parser-object">
<h2>Parser object<a class="headerlink" href="#parser-object" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="whoosh.qparser.QueryParser">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">QueryParser</tt><big>(</big><em>fieldname</em>, <em>schema</em>, <em>plugins=None</em>, <em>termclass=&lt;class 'whoosh.query.terms.Term'&gt;</em>, <em>phraseclass=&lt;class 'whoosh.query.positional.Phrase'&gt;</em>, <em>group=&lt;class 'whoosh.qparser.syntax.AndGroup'&gt;</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser" title="Permalink to this definition">¶</a></dt>
<dd><p>A hand-written query parser built on modular plug-ins. The default
configuration implements a powerful fielded query language similar to
Lucene&#8217;s.</p>
<p>You can use the <tt class="docutils literal"><span class="pre">plugins</span></tt> argument when creating the object to override
the default list of plug-ins, and/or use <tt class="docutils literal"><span class="pre">add_plugin()</span></tt> and/or
<tt class="docutils literal"><span class="pre">remove_plugin_class()</span></tt> to change the plug-ins included in the parser.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">whoosh</span> <span class="kn">import</span> <span class="n">qparser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">remove_plugin_class</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">WildcardPlugin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">PrefixPlugin</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">u&quot;hello there&quot;</span><span class="p">)</span>
<span class="go">And([Term(&quot;content&quot;, u&quot;hello&quot;), Term(&quot;content&quot;, u&quot;there&quot;)])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldname</strong> &#8211; the default field &#8211; the parser uses this as the
field for any terms without an explicit field.</li>
<li><strong>schema</strong> &#8211; a <a class="reference internal" href="fields.html#whoosh.fields.Schema" title="whoosh.fields.Schema"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.fields.Schema</span></tt></a> object to use when
parsing. The appropriate fields in the schema will be used to
tokenize terms/phrases before they are turned into query objects.
You can specify None for the schema to create a parser that does
not analyze the text of the query, usually for testing purposes.</li>
<li><strong>plugins</strong> &#8211; a list of plugins to use. WhitespacePlugin is
automatically included, do not put it in this list. This overrides
the default list of plugins. Classes in the list will be
automatically instantiated.</li>
<li><strong>termclass</strong> &#8211; the query class to use for individual search terms.
The default is <a class="reference internal" href="query.html#whoosh.query.Term" title="whoosh.query.Term"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Term</span></tt></a>.</li>
<li><strong>phraseclass</strong> &#8211; the query class to use for phrases. The default
is <a class="reference internal" href="query.html#whoosh.query.Phrase" title="whoosh.query.Phrase"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Phrase</span></tt></a>.</li>
<li><strong>group</strong> &#8211; the default grouping. <tt class="docutils literal"><span class="pre">AndGroup</span></tt> makes terms required
by default. <tt class="docutils literal"><span class="pre">OrGroup</span></tt> makes terms optional by default.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="whoosh.qparser.QueryParser.add_plugin">
<tt class="descname">add_plugin</tt><big>(</big><em>pin</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.add_plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the given plugin to the list of plugins in this parser.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.add_plugins">
<tt class="descname">add_plugins</tt><big>(</big><em>pins</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.add_plugins" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the given list of plugins to the list of plugins in this
parser.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.default_set">
<tt class="descname">default_set</tt><big>(</big><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.default_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default list of plugins to use.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.filterize">
<tt class="descname">filterize</tt><big>(</big><em>nodes</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.filterize" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a group of nodes and runs the filters provided by the parser&#8217;s
plugins.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.filters">
<tt class="descname">filters</tt><big>(</big><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a priorized list of filter functions provided by the
parser&#8217;s currently configured plugins.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.multitoken_query">
<tt class="descname">multitoken_query</tt><big>(</big><em>spec</em>, <em>texts</em>, <em>fieldname</em>, <em>termclass</em>, <em>boost</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.multitoken_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a query for multiple texts. This method implements the
intention specified in the field&#8217;s <tt class="docutils literal"><span class="pre">multitoken_query</span></tt> attribute,
which specifies what to do when strings that look like single terms
to the parser turn out to yield multiple tokens when analyzed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spec</strong> &#8211; a string describing how to join the text strings into a
query. This is usually the value of the field&#8217;s
<tt class="docutils literal"><span class="pre">multitoken_query</span></tt> attribute.</li>
<li><strong>texts</strong> &#8211; a list of token strings.</li>
<li><strong>fieldname</strong> &#8211; the name of the field.</li>
<li><strong>termclass</strong> &#8211; the query class to use for single terms.</li>
<li><strong>boost</strong> &#8211; the original term&#8217;s boost in the query string, should be
applied to the returned query object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.parse">
<tt class="descname">parse</tt><big>(</big><em>text</em>, <em>normalize=True</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses the input string and returns a <a class="reference internal" href="query.html#whoosh.query.Query" title="whoosh.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Query</span></tt></a>
object/tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>text</strong> &#8211; the unicode string to parse.</li>
<li><strong>normalize</strong> &#8211; whether to call normalize() on the query object/tree
before returning it. This should be left on unless you&#8217;re trying to
debug the parser output.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="query.html#whoosh.query.Query" title="whoosh.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Query</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.process">
<tt class="descname">process</tt><big>(</big><em>text</em>, <em>pos=0</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a group of syntax nodes corresponding to the given text,
tagged by the plugin Taggers and filtered by the plugin filters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text to tag.</li>
<li><strong>pos</strong> &#8211; the position in the text to start tagging at.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.remove_plugin">
<tt class="descname">remove_plugin</tt><big>(</big><em>pi</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.remove_plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the given plugin object from the list of plugins in this
parser.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.remove_plugin_class">
<tt class="descname">remove_plugin_class</tt><big>(</big><em>cls</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.remove_plugin_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any plugins of the given class from this parser.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.replace_plugin">
<tt class="descname">replace_plugin</tt><big>(</big><em>plugin</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.replace_plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes any plugins of the class of the given plugin and then adds
it. This is a convenience method to keep from having to call
<tt class="docutils literal"><span class="pre">remove_plugin_class</span></tt> followed by <tt class="docutils literal"><span class="pre">add_plugin</span></tt> each time you want
to reconfigure a default plugin.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">replace_plugin</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">NotPlugin</span><span class="p">(</span><span class="s">&quot;(^| )-&quot;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.tag">
<tt class="descname">tag</tt><big>(</big><em>text</em>, <em>pos=0</em>, <em>debug=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a group of syntax nodes corresponding to the given text,
created by matching the Taggers provided by the parser&#8217;s plugins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text to tag.</li>
<li><strong>pos</strong> &#8211; the position in the text to start tagging at.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.taggers">
<tt class="descname">taggers</tt><big>(</big><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.taggers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a priorized list of tagger objects provided by the parser&#8217;s
currently configured plugins.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.QueryParser.term_query">
<tt class="descname">term_query</tt><big>(</big><em>fieldname</em>, <em>text</em>, <em>termclass</em>, <em>boost=1.0</em>, <em>tokenize=True</em>, <em>removestops=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.QueryParser.term_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the appropriate query object for a single term in the query
string.</p>
</dd></dl>

</dd></dl>

<div class="section" id="pre-made-configurations">
<h3>Pre-made configurations<a class="headerlink" href="#pre-made-configurations" title="Permalink to this headline">¶</a></h3>
<p>The following functions return pre-configured QueryParser objects.</p>
<dl class="function">
<dt id="whoosh.qparser.MultifieldParser">
<tt class="descclassname">whoosh.qparser.</tt><tt class="descname">MultifieldParser</tt><big>(</big><em>fieldnames</em>, <em>schema</em>, <em>fieldboosts=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.MultifieldParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a QueryParser configured to search in multiple fields.</p>
<p>Instead of assigning unfielded clauses to a default field, this parser
transforms them into an OR clause that searches a list of fields. For
example, if the list of multi-fields is &#8220;f1&#8221;, &#8220;f2&#8221; and the query string is
&#8220;hello there&#8221;, the class will parse &#8220;(f1:hello OR f2:hello) (f1:there OR
f2:there)&#8221;. This is very useful when you have two textual fields (e.g.
&#8220;title&#8221; and &#8220;content&#8221;) you want to search by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldnames</strong> &#8211; a list of field names to search.</li>
<li><strong>fieldboosts</strong> &#8211; an optional dictionary mapping field names to boosts.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="whoosh.qparser.SimpleParser">
<tt class="descclassname">whoosh.qparser.</tt><tt class="descname">SimpleParser</tt><big>(</big><em>fieldname</em>, <em>schema</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SimpleParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a QueryParser configured to support only +, -, and phrase
syntax.</p>
</dd></dl>

<dl class="function">
<dt id="whoosh.qparser.DisMaxParser">
<tt class="descclassname">whoosh.qparser.</tt><tt class="descname">DisMaxParser</tt><big>(</big><em>fieldboosts</em>, <em>schema</em>, <em>tiebreak=0.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.DisMaxParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a QueryParser configured to support only +, -, and phrase
syntax, and which converts individual terms into DisjunctionMax queries
across a set of fields.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fieldboosts</strong> &#8211; a dictionary mapping field names to boosts.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="plug-ins">
<h2>Plug-ins<a class="headerlink" href="#plug-ins" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="whoosh.qparser.Plugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">Plugin</tt><a class="headerlink" href="#whoosh.qparser.Plugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for parser plugins.</p>
<dl class="method">
<dt id="whoosh.qparser.Plugin.filters">
<tt class="descname">filters</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#whoosh.qparser.Plugin.filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return a list of <tt class="docutils literal"><span class="pre">(filter_function,</span> <span class="pre">priority)</span></tt> tuples to
add to parser. Lower priority numbers run first.</p>
<p>Filter functions will be called with <tt class="docutils literal"><span class="pre">(parser,</span> <span class="pre">groupnode)</span></tt> and should
return a group node.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.Plugin.taggers">
<tt class="descname">taggers</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#whoosh.qparser.Plugin.taggers" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return a list of <tt class="docutils literal"><span class="pre">(Tagger,</span> <span class="pre">priority)</span></tt> tuples to add to the
syntax the parser understands. Lower priorities run first.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.SingleQuotePlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">SingleQuotePlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SingleQuotePlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify single &#8220;terms&#8221; containing spaces by
enclosing them in single quotes.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.PrefixPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">PrefixPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.PrefixPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify prefix queries by ending a term with an
asterisk.</p>
<p>This plugin is useful if you want the user to be able to create prefix but
not wildcard queries (for performance reasons). If you are including the
wildcard plugin, you should not include this plugin as well.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">myschema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">remove_plugin_class</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">WildcardPlugin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">PrefixPlugin</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;pre*&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.WildcardPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">WildcardPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.WildcardPlugin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.RegexPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">RegexPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.RegexPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify regular expression term queries.</p>
<p>The default syntax for a regular expression term is <tt class="docutils literal"><span class="pre">r&quot;termexpr&quot;</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">myschema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">RegexPlugin</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;foo title:r&quot;bar+&quot;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.BoostPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">BoostPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.BoostPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to boost clauses of the query using the circumflex.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">myschema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;hello there^2&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.GroupPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">GroupPlugin</tt><big>(</big><em>openexpr='[(]'</em>, <em>closeexpr='[)]'</em><big>)</big><a class="headerlink" href="#whoosh.qparser.GroupPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to group clauses using parentheses.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.EveryPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">EveryPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.EveryPlugin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.FieldsPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">FieldsPlugin</tt><big>(</big><em>expr='(?P&lt;text&gt;\w+|[*]):'</em>, <em>remove_unknown=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.FieldsPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify the field of a clause.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>expr</strong> &#8211; the regular expression to use for tagging fields.</li>
<li><strong>remove_unknown</strong> &#8211; if True, converts field specifications for
fields that aren&#8217;t in the schema into regular text.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.PhrasePlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">PhrasePlugin</tt><big>(</big><em>expr='&quot;(?P&lt;text&gt;.*?)&quot;(~(?P&lt;slop&gt;[1-9][0-9]*))?'</em><big>)</big><a class="headerlink" href="#whoosh.qparser.PhrasePlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify phrase queries inside double quotes.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.RangePlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">RangePlugin</tt><big>(</big><em>expr=None</em>, <em>excl_start='{'</em>, <em>excl_end='}'</em><big>)</big><a class="headerlink" href="#whoosh.qparser.RangePlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to specify term ranges.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.OperatorsPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">OperatorsPlugin</tt><big>(</big><em>ops=None</em>, <em>clean=False</em>, <em>And='(?&lt;=\s)AND(?=\s)'</em>, <em>Or='(?&lt;=\s)OR(?=\s)'</em>, <em>AndNot='(?&lt;=\s)ANDNOT(?=\s)'</em>, <em>AndMaybe='(?&lt;=\s)ANDMAYBE(?=\s)'</em>, <em>Not='(^|(?&lt;=(\s|[()])))NOT(?=\s)'</em>, <em>Require='(^|(?&lt;=\s))REQUIRE(?=\s)'</em><big>)</big><a class="headerlink" href="#whoosh.qparser.OperatorsPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, adds the AND, OR, ANDNOT, ANDMAYBE, and NOT operators to
the parser syntax. This plugin scans the token stream for subclasses of
<a class="reference internal" href="#whoosh.qparser.Operator" title="whoosh.qparser.Operator"><tt class="xref py py-class docutils literal"><span class="pre">Operator</span></tt></a> and calls their <tt class="xref py py-meth docutils literal"><span class="pre">Operator.make_group()</span></tt> methods
to allow them to manipulate the stream.</p>
<p>There are two levels of configuration available.</p>
<p>The first level is to change the regular expressions of the default
operators, using the <tt class="docutils literal"><span class="pre">And</span></tt>, <tt class="docutils literal"><span class="pre">Or</span></tt>, <tt class="docutils literal"><span class="pre">AndNot</span></tt>, <tt class="docutils literal"><span class="pre">AndMaybe</span></tt>, and/or
<tt class="docutils literal"><span class="pre">Not</span></tt> keyword arguments. The keyword value can be a pattern string or
a compiled expression, or None to remove the operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="s">&quot;content&quot;</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
<span class="n">cp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">OperatorsPlugin</span><span class="p">(</span><span class="n">And</span><span class="o">=</span><span class="s">&quot;&amp;&quot;</span><span class="p">,</span> <span class="n">Or</span><span class="o">=</span><span class="s">&quot;\|&quot;</span><span class="p">,</span> <span class="n">AndNot</span><span class="o">=</span><span class="s">&quot;&amp;!&quot;</span><span class="p">,</span>
                             <span class="n">AndMaybe</span><span class="o">=</span><span class="s">&quot;&amp;~&quot;</span><span class="p">,</span> <span class="n">Not</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="n">qp</span><span class="o">.</span><span class="n">replace_plugin</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also specify a list of <tt class="docutils literal"><span class="pre">(OpTagger,</span> <span class="pre">priority)</span></tt> pairs as the first
argument to the initializer to use custom operators. See <a class="reference internal" href="../parsing.html#custom-op"><em>Creating custom operators</em></a>
for more information on this.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.PlusMinusPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">PlusMinusPlugin</tt><big>(</big><em>plusexpr='\+'</em>, <em>minusexpr='-'</em><big>)</big><a class="headerlink" href="#whoosh.qparser.PlusMinusPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to use + and - in a flat OR query to specify required
and prohibited terms.</p>
<p>This is the basis for the parser configuration returned by
<tt class="docutils literal"><span class="pre">SimpleParser()</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.GtLtPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">GtLtPlugin</tt><big>(</big><em>expr=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.GtLtPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the user to use greater than/less than symbols to create range
queries:</p>
<div class="highlight-python"><div class="highlight"><pre>a:&gt;100 b:&lt;=z c:&gt;=-1.4 d:&lt;mz
</pre></div>
</div>
<p>This is the equivalent of:</p>
<div class="highlight-python"><div class="highlight"><pre>a:{100 to] b:[to z] c:[-1.4 to] d:[to mz}
</pre></div>
</div>
<p>The plugin recognizes <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">=&gt;</span></tt>, and <tt class="docutils literal"><span class="pre">=&lt;</span></tt>
after a field specifier. The field specifier is required. You cannot do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt;100
</pre></div>
</div>
<p>This plugin requires the FieldsPlugin and RangePlugin to work.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.MultifieldPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">MultifieldPlugin</tt><big>(</big><em>fieldnames</em>, <em>fieldboosts=None</em>, <em>group=&lt;class 'whoosh.qparser.syntax.OrGroup'&gt;</em><big>)</big><a class="headerlink" href="#whoosh.qparser.MultifieldPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts any unfielded terms into OR clauses that search for the
term in a specified list of fields.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span> <span class="o">=</span> <span class="n">qparser</span><span class="o">.</span><span class="n">QueryParser</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">myschema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">qparser</span><span class="o">.</span><span class="n">MultifieldPlugin</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;alfa c:bravo&quot;</span><span class="p">)</span>
<span class="go">And([Or([Term(&quot;a&quot;, &quot;alfa&quot;), Term(&quot;b&quot;, &quot;alfa&quot;)]), Term(&quot;c&quot;, &quot;bravo&quot;)])</span>
</pre></div>
</div>
<p>This plugin is the basis for the <tt class="docutils literal"><span class="pre">MultifieldParser</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldnames</strong> &#8211; a list of fields to search.</li>
<li><strong>fieldboosts</strong> &#8211; an optional dictionary mapping field names to
a boost to use for that field.</li>
<li><strong>group</strong> &#8211; the group to use to relate the fielded terms to each
other.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.FieldAliasPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">FieldAliasPlugin</tt><big>(</big><em>fieldmap</em><big>)</big><a class="headerlink" href="#whoosh.qparser.FieldAliasPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the ability to use &#8220;aliases&#8221; of fields in the query string.</p>
<p>This plugin is useful for allowing users of languages that can&#8217;t be
represented in ASCII to use field names in their own language, and
translate them into the &#8220;real&#8221; field names, which must be valid Python
identifiers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Allow users to use &#39;body&#39; or &#39;text&#39; to refer to the &#39;content&#39; field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">add_plugin</span><span class="p">(</span><span class="n">FieldAliasPlugin</span><span class="p">({</span><span class="s">&quot;content&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;body&quot;</span><span class="p">,</span> <span class="s">&quot;text&quot;</span><span class="p">]}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;text:hello&quot;</span><span class="p">)</span>
<span class="go">Term(&quot;content&quot;, &quot;hello&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.CopyFieldPlugin">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">CopyFieldPlugin</tt><big>(</big><em>map</em>, <em>group=&lt;class 'whoosh.qparser.syntax.OrGroup'&gt;</em>, <em>mirror=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.CopyFieldPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks for basic syntax nodes (terms, prefixes, wildcards, phrases, etc.)
occurring in a certain field and replaces it with a group (by default OR)
containing the original token and the token copied to a new field.</p>
<p>For example, the query:</p>
<div class="highlight-python"><div class="highlight"><pre>hello name:matt
</pre></div>
</div>
<p>could be automatically converted by <tt class="docutils literal"><span class="pre">CopyFieldPlugin({&quot;name&quot;,</span> <span class="pre">&quot;author&quot;})</span></tt>
to:</p>
<div class="highlight-python"><div class="highlight"><pre>hello (name:matt OR author:matt)
</pre></div>
</div>
<p>This is useful where one field was indexed with a differently-analyzed copy
of another, and you want the query to search both fields.</p>
<p>You can specify a different group type with the <tt class="docutils literal"><span class="pre">group</span></tt> keyword. You can
also specify <tt class="docutils literal"><span class="pre">group=None</span></tt>, in which case the copied node is inserted
&#8220;inline&#8221; next to the original, instead of in a new group:</p>
<div class="highlight-python"><div class="highlight"><pre>hello name:matt author:matt
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map</strong> &#8211; a dictionary mapping names of fields to copy to the
names of the destination fields.</li>
<li><strong>group</strong> &#8211; the type of group to create in place of the original
token. You can specify <tt class="docutils literal"><span class="pre">group=None</span></tt> to put the copied node
&#8220;inline&#8221; next to the original node instead of in a new group.</li>
<li><strong>two_way</strong> &#8211; if True, the plugin copies both ways, so if the user
specifies a query in the &#8216;toname&#8217; field, it will be copied to
the &#8216;fromname&#8217; field.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="syntax-node-objects">
<h2>Syntax node objects<a class="headerlink" href="#syntax-node-objects" title="Permalink to this headline">¶</a></h2>
<div class="section" id="base-nodes">
<h3>Base nodes<a class="headerlink" href="#base-nodes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="whoosh.qparser.SyntaxNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">SyntaxNode</tt><a class="headerlink" href="#whoosh.qparser.SyntaxNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for nodes that make up the abstract syntax tree (AST) of a
parsed user query string. The AST is an intermediate step, generated
from the query string, then converted into a <a class="reference internal" href="query.html#whoosh.query.Query" title="whoosh.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Query</span></tt></a>
tree by calling the <tt class="docutils literal"><span class="pre">query()</span></tt> method on the nodes.</p>
<p>Instances have the following required attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">has_fieldname</span></tt></dt>
<dd>True if this node has a <tt class="docutils literal"><span class="pre">fieldname</span></tt> attribute.</dd>
<dt><tt class="docutils literal"><span class="pre">has_text</span></tt></dt>
<dd>True if this node has a <tt class="docutils literal"><span class="pre">text</span></tt> attribute</dd>
<dt><tt class="docutils literal"><span class="pre">has_boost</span></tt></dt>
<dd>True if this node has a <tt class="docutils literal"><span class="pre">boost</span></tt> attribute.</dd>
<dt><tt class="docutils literal"><span class="pre">startchar</span></tt></dt>
<dd>The character position in the original text at which this node started.</dd>
<dt><tt class="docutils literal"><span class="pre">endchar</span></tt></dt>
<dd>The character position in the original text at which this node ended.</dd>
</dl>
<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.is_ws">
<tt class="descname">is_ws</tt><big>(</big><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.is_ws" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if this node is ignorable whitespace.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.query">
<tt class="descname">query</tt><big>(</big><em>parser</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="query.html#whoosh.query.Query" title="whoosh.query.Query"><tt class="xref py py-class docutils literal"><span class="pre">whoosh.query.Query</span></tt></a> instance corresponding to this
syntax tree node.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.r">
<tt class="descname">r</tt><big>(</big><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a basic representation of this node. The base class&#8217;s
<tt class="docutils literal"><span class="pre">__repr__</span></tt> method calls this, then does the extra busy work of adding
fieldname and boost where appropriate.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.set_boost">
<tt class="descname">set_boost</tt><big>(</big><em>boost</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.set_boost" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the boost associated with this node.</p>
<p>For nodes that don&#8217;t have a boost, this is a no-op.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.set_fieldname">
<tt class="descname">set_fieldname</tt><big>(</big><em>name</em>, <em>override=False</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.set_fieldname" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the fieldname associated with this node. If <tt class="docutils literal"><span class="pre">override</span></tt> is
False (the default), the fieldname will only be replaced if this node
does not already have a fieldname set.</p>
<p>For nodes that don&#8217;t have a fieldname, this is a no-op.</p>
</dd></dl>

<dl class="method">
<dt id="whoosh.qparser.SyntaxNode.set_range">
<tt class="descname">set_range</tt><big>(</big><em>startchar</em>, <em>endchar</em><big>)</big><a class="headerlink" href="#whoosh.qparser.SyntaxNode.set_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the character range associated with this node.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nodes">
<h3>Nodes<a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="whoosh.qparser.FieldnameNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">FieldnameNode</tt><big>(</big><em>fieldname</em>, <em>original</em><big>)</big><a class="headerlink" href="#whoosh.qparser.FieldnameNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract syntax tree node for field name assignments.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.TextNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">TextNode</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#whoosh.qparser.TextNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate base class for basic nodes that search for text, such as
term queries, wildcards, prefixes, etc.</p>
<p>Instances have the following attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">qclass</span></tt></dt>
<dd>If a subclass does not override <tt class="docutils literal"><span class="pre">query()</span></tt>, the base class will use
this class to construct the query.</dd>
<dt><tt class="docutils literal"><span class="pre">tokenize</span></tt></dt>
<dd>If True and the subclass does not override <tt class="docutils literal"><span class="pre">query()</span></tt>, the node&#8217;s text
will be tokenized before constructing the query</dd>
<dt><tt class="docutils literal"><span class="pre">removestops</span></tt></dt>
<dd>If True and the subclass does not override <tt class="docutils literal"><span class="pre">query()</span></tt>, and the field&#8217;s
analyzer has a stop word filter, stop words will be removed from the
text before constructing the query.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.WordNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">WordNode</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#whoosh.qparser.WordNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Syntax node for term queries.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.RangeNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">RangeNode</tt><big>(</big><em>start</em>, <em>end</em>, <em>startexcl</em>, <em>endexcl</em><big>)</big><a class="headerlink" href="#whoosh.qparser.RangeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Syntax node for range queries.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.MarkerNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">MarkerNode</tt><a class="headerlink" href="#whoosh.qparser.MarkerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for nodes that only exist to mark places in the tree.</p>
</dd></dl>

</div>
<div class="section" id="group-nodes">
<h3>Group nodes<a class="headerlink" href="#group-nodes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="whoosh.qparser.GroupNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">GroupNode</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.GroupNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for abstract syntax tree node types that group together
sub-nodes.</p>
<p>Instances have the following attributes:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">merging</span></tt></dt>
<dd>True if side-by-side instances of this group can be merged into a
single group.</dd>
<dt><tt class="docutils literal"><span class="pre">qclass</span></tt></dt>
<dd>If a subclass doesn&#8217;t override <tt class="docutils literal"><span class="pre">query()</span></tt>, the base class will simply
wrap this class around the queries returned by the subnodes.</dd>
</dl>
<p>This class implements a number of list methods for operating on the
subnodes.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.BinaryGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">BinaryGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.BinaryGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate base class for group nodes that have two subnodes and
whose <tt class="docutils literal"><span class="pre">qclass</span></tt> initializer takes two arguments instead of a list.</p>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.ErrorNode">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">ErrorNode</tt><big>(</big><em>message</em>, <em>node=None</em><big>)</big><a class="headerlink" href="#whoosh.qparser.ErrorNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.AndGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">AndGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.AndGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.OrGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">OrGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.OrGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.AndNotGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">AndNotGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.AndNotGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.AndMaybeGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">AndMaybeGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.AndMaybeGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.DisMaxGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">DisMaxGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.DisMaxGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.RequireGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">RequireGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.RequireGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="whoosh.qparser.NotGroup">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">NotGroup</tt><big>(</big><em>nodes=None</em>, <em>boost=1.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#whoosh.qparser.NotGroup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="operators">
<h3>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="whoosh.qparser.Operator">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">Operator</tt><big>(</big><em>text</em>, <em>grouptype</em>, <em>leftassoc=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.Operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for PrefixOperator, PostfixOperator, and InfixOperator.</p>
<p>Operators work by moving the nodes they apply to (e.g. for prefix operator,
the previous node, for infix operator, the nodes on either side, etc.) into
a group node. The group provides the code for what to do with the nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text of the operator in the query string.</li>
<li><strong>grouptype</strong> &#8211; the type of group to create in place of the operator
and the node(s) it operates on.</li>
<li><strong>leftassoc</strong> &#8211; for infix opeators, whether the operator is left
associative. use <tt class="docutils literal"><span class="pre">leftassoc=False</span></tt> for right-associative infix
operators.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.PrefixOperator">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">PrefixOperator</tt><big>(</big><em>text</em>, <em>grouptype</em>, <em>leftassoc=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.PrefixOperator" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text of the operator in the query string.</li>
<li><strong>grouptype</strong> &#8211; the type of group to create in place of the operator
and the node(s) it operates on.</li>
<li><strong>leftassoc</strong> &#8211; for infix opeators, whether the operator is left
associative. use <tt class="docutils literal"><span class="pre">leftassoc=False</span></tt> for right-associative infix
operators.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.PostfixOperator">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">PostfixOperator</tt><big>(</big><em>text</em>, <em>grouptype</em>, <em>leftassoc=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.PostfixOperator" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text of the operator in the query string.</li>
<li><strong>grouptype</strong> &#8211; the type of group to create in place of the operator
and the node(s) it operates on.</li>
<li><strong>leftassoc</strong> &#8211; for infix opeators, whether the operator is left
associative. use <tt class="docutils literal"><span class="pre">leftassoc=False</span></tt> for right-associative infix
operators.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="whoosh.qparser.InfixOperator">
<em class="property">class </em><tt class="descclassname">whoosh.qparser.</tt><tt class="descname">InfixOperator</tt><big>(</big><em>text</em>, <em>grouptype</em>, <em>leftassoc=True</em><big>)</big><a class="headerlink" href="#whoosh.qparser.InfixOperator" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> &#8211; the text of the operator in the query string.</li>
<li><strong>grouptype</strong> &#8211; the type of group to create in place of the operator
and the node(s) it operates on.</li>
<li><strong>leftassoc</strong> &#8211; for infix opeators, whether the operator is left
associative. use <tt class="docutils literal"><span class="pre">leftassoc=False</span></tt> for right-associative infix
operators.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">qparser</span></tt> module</a><ul>
<li><a class="reference internal" href="#parser-object">Parser object</a><ul>
<li><a class="reference internal" href="#pre-made-configurations">Pre-made configurations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#plug-ins">Plug-ins</a></li>
<li><a class="reference internal" href="#syntax-node-objects">Syntax node objects</a><ul>
<li><a class="reference internal" href="#base-nodes">Base nodes</a></li>
<li><a class="reference internal" href="#nodes">Nodes</a></li>
<li><a class="reference internal" href="#group-nodes">Group nodes</a></li>
<li><a class="reference internal" href="#operators">Operators</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="matching.html"
                        title="previous chapter"><tt class="docutils literal"><span class="pre">matching</span></tt> module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="query.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">query</span></tt> module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/qparser.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="query.html" title="query module"
             >next</a> |</li>
        <li class="right" >
          <a href="matching.html" title="matching module"
             >previous</a> |</li>
        <li><a href="../index.html">Whoosh 2.5.7 documentation</a> &raquo;</li>
          <li><a href="api.html" >Whoosh API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2007-2012 Matt Chaput.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>